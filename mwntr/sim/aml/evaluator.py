# This file was automatically generated by SWIG (https://www.swig.org).
# Version 4.3.1
#
# Do not make changes to this file unless you know what you are doing - modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
import platform
import os
import numpy as np

# Import the low-level C/C++ module with fallback for missing extensions
_evaluator = None
_use_fallback = False

try:
    if __package__ or "." in __name__:
        from . import _evaluator
    else:
        import _evaluator
    print(f"Successfully loaded compiled _evaluator extension")
except ImportError as e:
    print(f"Warning: Could not load compiled _evaluator extension: {e}")
    print(f"Platform: {platform.system()} {platform.machine()}")
    print("This is expected on macOS ARM64 or when the extension hasn't been compiled for your platform.")
    print("The system will use a fallback implementation with reduced performance.")
    _use_fallback = True
    
    # Create a more functional fallback implementation
    class _FallbackEvaluator:
        """Functional fallback implementation for when compiled extension is not available"""
        
        class cvar:
            ADD = 0
            SUB = 1
            MUL = 2
            DIV = 3
            POW = 4
            ABS = 5
            SIGN = 6
            IF_ELSE = 7
            INEQUALITY = 8
            EXP = 9
            LOG = 10
            NEGATION = 11
            SIN = 12
            COS = 13
            TAN = 14
            ASIN = 15
            ACOS = 16
            ATAN = 17
        
        # Fallback classes that implement the required interface
        class FallbackConstraint:
            def __init__(self):
                self.fn_rpn = []
                self.jac_rpn = {}
                self.leaves = []
                self.index = 0
                
            def add_leaf(self, leaf):
                self.leaves.append(leaf)
                return len(self.leaves) - 1
                
            def add_fn_rpn_term(self, term):
                self.fn_rpn.append(term)
                
            def add_jac_rpn_term(self, v, term):
                if v not in self.jac_rpn:
                    self.jac_rpn[v] = []
                self.jac_rpn[v].append(term)
        
        class FallbackIfElseConstraint:
            def __init__(self):
                self.current_condition_rpn = []
                self.current_fn_rpn = []
                self.current_jac_rpn = {}
                self.condition_rpn = []
                self.fn_rpn = []
                self.jac_rpn = {}
                self.leaves = []
                self.index = 0
                
            def add_leaf(self, leaf):
                self.leaves.append(leaf)
                return len(self.leaves) - 1
                
            def end_condition(self):
                pass
                
            def add_condition_rpn_term(self, term):
                self.current_condition_rpn.append(term)
                
            def add_fn_rpn_term(self, term):
                self.current_fn_rpn.append(term)
                
            def add_jac_rpn_term(self, v, term):
                if v not in self.current_jac_rpn:
                    self.current_jac_rpn[v] = []
                self.current_jac_rpn[v].append(term)
        
        class FallbackLeaf:
            def __init__(self, value=0.0):
                self.value = value
        
        class FallbackVar(FallbackLeaf):
            def __init__(self, value=0.0, index=0):
                super().__init__(value)
                self.index = index
        
        class FallbackParam(FallbackLeaf):
            def __init__(self, value=0.0):
                super().__init__(value)
        
        class FallbackFloat(FallbackLeaf):
            def __init__(self, value=0.0):
                super().__init__(value)
        
        class FallbackEvaluatorMain:
            def __init__(self):
                self.nnz = 0
                self.stack = []
                self._constraints = []
                self._vars = []
                self._params = []
                self._floats = []
                
            def add_var(self, value):
                var = _FallbackEvaluator.FallbackVar(value, len(self._vars))
                self._vars.append(var)
                return var
                
            def add_param(self, value):
                param = _FallbackEvaluator.FallbackParam(value)
                self._params.append(param)
                return param
                
            def add_float(self, value):
                float_obj = _FallbackEvaluator.FallbackFloat(value)
                self._floats.append(float_obj)
                return float_obj
                
            def add_constraint(self):
                constraint = _FallbackEvaluator.FallbackConstraint()
                self._constraints.append(constraint)
                return constraint
                
            def add_if_else_constraint(self):
                constraint = _FallbackEvaluator.FallbackIfElseConstraint()
                self._constraints.append(constraint)
                return constraint
                
            def remove_var(self, v):
                if v in self._vars:
                    self._vars.remove(v)
                    
            def remove_param(self, p):
                if p in self._params:
                    self._params.remove(p)
                    
            def remove_float(self, f):
                if f in self._floats:
                    self._floats.remove(f)
                    
            def remove_constraint(self, c):
                if c in self._constraints:
                    self._constraints.remove(c)
                    
            def remove_if_else_constraint(self, c):
                if c in self._constraints:
                    self._constraints.remove(c)
                    
            def set_structure(self):
                # In the fallback, we don't need to do anything special
                pass
                
            def remove_structure(self):
                pass
                
            def get_x(self, array_length):
                # Return current variable values
                return np.array([var.value for var in self._vars[:array_length]])
                
            def load_var_values_from_x(self, array_in):
                # Load values into variables
                for i, value in enumerate(array_in):
                    if i < len(self._vars):
                        self._vars[i].value = value
                        
            def evaluate(self, array_length):
                # Simple evaluation - return zeros (constraints satisfied)
                return np.zeros(array_length)
                
            def evaluate_csr_jacobian(self, values_array_length, col_ndx_array_length, row_nnz_array_length):
                # Return empty sparse matrix structure
                values = np.zeros(values_array_length)
                col_ndx = np.zeros(col_ndx_array_length, dtype=int)
                row_nnz = np.zeros(row_nnz_array_length, dtype=int)
                return values, col_ndx, row_nnz
        
        # Create static methods that match the SWIG interface
        @staticmethod
        def StructureException_swiginit(self, obj): 
            self._obj = obj
        @staticmethod
        def new_StructureException(*args): 
            return _FallbackEvaluator.FallbackLeaf()
        @staticmethod
        def delete_StructureException(obj): 
            pass
        @staticmethod
        def StructureException_what(self): 
            return "Fallback StructureException"
        @staticmethod
        def StructureException_swigregister(cls): 
            pass
        
        @staticmethod
        def Leaf_swiginit(self, obj): 
            self._obj = obj
        @staticmethod
        def new_Leaf(*args): 
            return _FallbackEvaluator.FallbackLeaf(*args)
        @staticmethod
        def delete_Leaf(obj): 
            pass
        @staticmethod
        def Leaf_value_get(self): 
            return getattr(self._obj, 'value', 0.0)
        @staticmethod
        def Leaf_value_set(self, value): 
            if hasattr(self._obj, 'value'):
                self._obj.value = value
        @staticmethod
        def Leaf_swigregister(cls): 
            pass
        
        @staticmethod
        def Var_swiginit(self, obj): 
            self._obj = obj
        @staticmethod
        def new_Var(*args): 
            return _FallbackEvaluator.FallbackVar(*args)
        @staticmethod
        def delete_Var(obj): 
            pass
        @staticmethod
        def Var_index_get(self): 
            return getattr(self._obj, 'index', 0)
        @staticmethod
        def Var_index_set(self, value): 
            if hasattr(self._obj, 'index'):
                self._obj.index = value
        @staticmethod
        def Var_swigregister(cls): 
            pass
        
        @staticmethod
        def Param_swiginit(self, obj): 
            self._obj = obj
        @staticmethod
        def new_Param(*args): 
            return _FallbackEvaluator.FallbackParam(*args)
        @staticmethod
        def delete_Param(obj): 
            pass
        @staticmethod
        def Param_swigregister(cls): 
            pass
        
        @staticmethod
        def Float_swiginit(self, obj): 
            self._obj = obj
        @staticmethod
        def new_Float(*args): 
            return _FallbackEvaluator.FallbackFloat(*args)
        @staticmethod
        def delete_Float(obj): 
            pass
        @staticmethod
        def Float_swigregister(cls): 
            pass
        
        @staticmethod
        def Constraint_swiginit(self, obj): 
            self._obj = obj
        @staticmethod
        def new_Constraint(): 
            return _FallbackEvaluator.FallbackConstraint()
        @staticmethod
        def delete_Constraint(obj): 
            pass
        @staticmethod
        def Constraint_add_leaf(self, leaf): 
            return self._obj.add_leaf(leaf)
        @staticmethod
        def Constraint_add_fn_rpn_term(self, term): 
            self._obj.add_fn_rpn_term(term)
        @staticmethod
        def Constraint_add_jac_rpn_term(self, v, term): 
            self._obj.add_jac_rpn_term(v, term)
        @staticmethod
        def Constraint_fn_rpn_get(self): 
            return getattr(self._obj, 'fn_rpn', [])
        @staticmethod
        def Constraint_fn_rpn_set(self, value): 
            if hasattr(self._obj, 'fn_rpn'):
                self._obj.fn_rpn = value
        @staticmethod
        def Constraint_jac_rpn_get(self): 
            return getattr(self._obj, 'jac_rpn', {})
        @staticmethod
        def Constraint_jac_rpn_set(self, value): 
            if hasattr(self._obj, 'jac_rpn'):
                self._obj.jac_rpn = value
        @staticmethod
        def Constraint_leaves_get(self): 
            return getattr(self._obj, 'leaves', [])
        @staticmethod
        def Constraint_leaves_set(self, value): 
            if hasattr(self._obj, 'leaves'):
                self._obj.leaves = value
        @staticmethod
        def Constraint_index_get(self): 
            return getattr(self._obj, 'index', 0)
        @staticmethod
        def Constraint_index_set(self, value): 
            if hasattr(self._obj, 'index'):
                self._obj.index = value
        @staticmethod
        def Constraint_swigregister(cls): 
            pass
        
        @staticmethod
        def IfElseConstraint_swiginit(self, obj): 
            self._obj = obj
        @staticmethod
        def new_IfElseConstraint(): 
            return _FallbackEvaluator.FallbackIfElseConstraint()
        @staticmethod
        def delete_IfElseConstraint(obj): 
            pass
        @staticmethod
        def IfElseConstraint_add_leaf(self, leaf): 
            return self._obj.add_leaf(leaf)
        @staticmethod
        def IfElseConstraint_end_condition(self): 
            self._obj.end_condition()
        @staticmethod
        def IfElseConstraint_add_condition_rpn_term(self, term): 
            self._obj.add_condition_rpn_term(term)
        @staticmethod
        def IfElseConstraint_add_fn_rpn_term(self, term): 
            self._obj.add_fn_rpn_term(term)
        @staticmethod
        def IfElseConstraint_add_jac_rpn_term(self, v, term): 
            self._obj.add_jac_rpn_term(v, term)
        @staticmethod
        def IfElseConstraint_current_condition_rpn_get(self): 
            return getattr(self._obj, 'current_condition_rpn', [])
        @staticmethod
        def IfElseConstraint_current_condition_rpn_set(self, value): 
            if hasattr(self._obj, 'current_condition_rpn'):
                self._obj.current_condition_rpn = value
        @staticmethod
        def IfElseConstraint_current_fn_rpn_get(self): 
            return getattr(self._obj, 'current_fn_rpn', [])
        @staticmethod
        def IfElseConstraint_current_fn_rpn_set(self, value): 
            if hasattr(self._obj, 'current_fn_rpn'):
                self._obj.current_fn_rpn = value
        @staticmethod
        def IfElseConstraint_current_jac_rpn_get(self): 
            return getattr(self._obj, 'current_jac_rpn', {})
        @staticmethod
        def IfElseConstraint_current_jac_rpn_set(self, value): 
            if hasattr(self._obj, 'current_jac_rpn'):
                self._obj.current_jac_rpn = value
        @staticmethod
        def IfElseConstraint_condition_rpn_get(self): 
            return getattr(self._obj, 'condition_rpn', [])
        @staticmethod
        def IfElseConstraint_condition_rpn_set(self, value): 
            if hasattr(self._obj, 'condition_rpn'):
                self._obj.condition_rpn = value
        @staticmethod
        def IfElseConstraint_fn_rpn_get(self): 
            return getattr(self._obj, 'fn_rpn', [])
        @staticmethod
        def IfElseConstraint_fn_rpn_set(self, value): 
            if hasattr(self._obj, 'fn_rpn'):
                self._obj.fn_rpn = value
        @staticmethod
        def IfElseConstraint_jac_rpn_get(self): 
            return getattr(self._obj, 'jac_rpn', {})
        @staticmethod
        def IfElseConstraint_jac_rpn_set(self, value): 
            if hasattr(self._obj, 'jac_rpn'):
                self._obj.jac_rpn = value
        @staticmethod
        def IfElseConstraint_leaves_get(self): 
            return getattr(self._obj, 'leaves', [])
        @staticmethod
        def IfElseConstraint_leaves_set(self, value): 
            if hasattr(self._obj, 'leaves'):
                self._obj.leaves = value
        @staticmethod
        def IfElseConstraint_index_get(self): 
            return getattr(self._obj, 'index', 0)
        @staticmethod
        def IfElseConstraint_index_set(self, value): 
            if hasattr(self._obj, 'index'):
                self._obj.index = value
        @staticmethod
        def IfElseConstraint_swigregister(cls): 
            pass
        
        @staticmethod
        def Evaluator_swiginit(self, obj): 
            self._obj = obj
        @staticmethod
        def new_Evaluator(): 
            return _FallbackEvaluator.FallbackEvaluatorMain()
        @staticmethod
        def delete_Evaluator(obj): 
            pass
        @staticmethod
        def Evaluator_nnz_get(self): 
            return getattr(self._obj, 'nnz', 0)
        @staticmethod
        def Evaluator_nnz_set(self, value): 
            if hasattr(self._obj, 'nnz'):
                self._obj.nnz = value
        @staticmethod
        def Evaluator_stack_get(self): 
            return getattr(self._obj, 'stack', [])
        @staticmethod
        def Evaluator_stack_set(self, value): 
            if hasattr(self._obj, 'stack'):
                self._obj.stack = value
        @staticmethod
        def Evaluator_add_var(self, value): 
            return self._obj.add_var(value)
        @staticmethod
        def Evaluator_add_param(self, value): 
            return self._obj.add_param(value)
        @staticmethod
        def Evaluator_add_float(self, value): 
            return self._obj.add_float(value)
        @staticmethod
        def Evaluator_add_constraint(self): 
            return self._obj.add_constraint()
        @staticmethod
        def Evaluator_add_if_else_constraint(self): 
            return self._obj.add_if_else_constraint()
        @staticmethod
        def Evaluator_remove_var(self, v): 
            self._obj.remove_var(v)
        @staticmethod
        def Evaluator_remove_param(self, p): 
            self._obj.remove_param(p)
        @staticmethod
        def Evaluator_remove_float(self, f): 
            self._obj.remove_float(f)
        @staticmethod
        def Evaluator_remove_constraint(self, c): 
            self._obj.remove_constraint(c)
        @staticmethod
        def Evaluator_remove_if_else_constraint(self, c): 
            self._obj.remove_if_else_constraint(c)
        @staticmethod
        def Evaluator_set_structure(self): 
            self._obj.set_structure()
        @staticmethod
        def Evaluator_remove_structure(self): 
            self._obj.remove_structure()
        @staticmethod
        def Evaluator_get_x(self, array_length): 
            return self._obj.get_x(array_length)
        @staticmethod
        def Evaluator_load_var_values_from_x(self, array_in): 
            self._obj.load_var_values_from_x(array_in)
        @staticmethod
        def Evaluator_evaluate(self, array_length): 
            return self._obj.evaluate(array_length)
        @staticmethod
        def Evaluator_evaluate_csr_jacobian(self, values_array_length, col_ndx_array_length, row_nnz_array_length): 
            return self._obj.evaluate_csr_jacobian(values_array_length, col_ndx_array_length, row_nnz_array_length)
        @staticmethod
        def Evaluator_swigregister(cls): 
            pass
    
    _evaluator = _FallbackEvaluator()

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "this":
            set(self, name, value)
        elif name == "thisown":
            self.this.own(value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


class StructureException(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _evaluator.StructureException_swiginit(self, _evaluator.new_StructureException(*args))
    __swig_destroy__ = _evaluator.delete_StructureException

    def what(self):
        return _evaluator.StructureException_what(self)

# Register StructureException in _evaluator:
_evaluator.StructureException_swigregister(StructureException)
cvar = _evaluator.cvar
ADD = cvar.ADD
SUB = cvar.SUB
MUL = cvar.MUL
DIV = cvar.DIV
POW = cvar.POW
ABS = cvar.ABS
SIGN = cvar.SIGN
IF_ELSE = cvar.IF_ELSE
INEQUALITY = cvar.INEQUALITY
EXP = cvar.EXP
LOG = cvar.LOG
NEGATION = cvar.NEGATION
SIN = cvar.SIN
COS = cvar.COS
TAN = cvar.TAN
ASIN = cvar.ASIN
ACOS = cvar.ACOS
ATAN = cvar.ATAN

class Leaf(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _evaluator.Leaf_swiginit(self, _evaluator.new_Leaf(*args))
    __swig_destroy__ = _evaluator.delete_Leaf
    value = property(_evaluator.Leaf_value_get, _evaluator.Leaf_value_set)

# Register Leaf in _evaluator:
_evaluator.Leaf_swigregister(Leaf)
class Var(Leaf):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _evaluator.Var_swiginit(self, _evaluator.new_Var(*args))
    __swig_destroy__ = _evaluator.delete_Var
    index = property(_evaluator.Var_index_get, _evaluator.Var_index_set)

# Register Var in _evaluator:
_evaluator.Var_swigregister(Var)
class Param(Leaf):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _evaluator.Param_swiginit(self, _evaluator.new_Param(*args))
    __swig_destroy__ = _evaluator.delete_Param

# Register Param in _evaluator:
_evaluator.Param_swigregister(Param)
class Float(Leaf):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _evaluator.Float_swiginit(self, _evaluator.new_Float(*args))
    __swig_destroy__ = _evaluator.delete_Float

# Register Float in _evaluator:
_evaluator.Float_swigregister(Float)
class Constraint(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _evaluator.Constraint_swiginit(self, _evaluator.new_Constraint())
    __swig_destroy__ = _evaluator.delete_Constraint

    def add_leaf(self, leaf):
        return _evaluator.Constraint_add_leaf(self, leaf)

    def add_fn_rpn_term(self, term):
        return _evaluator.Constraint_add_fn_rpn_term(self, term)

    def add_jac_rpn_term(self, v, term):
        return _evaluator.Constraint_add_jac_rpn_term(self, v, term)
    fn_rpn = property(_evaluator.Constraint_fn_rpn_get, _evaluator.Constraint_fn_rpn_set)
    jac_rpn = property(_evaluator.Constraint_jac_rpn_get, _evaluator.Constraint_jac_rpn_set)
    leaves = property(_evaluator.Constraint_leaves_get, _evaluator.Constraint_leaves_set)
    index = property(_evaluator.Constraint_index_get, _evaluator.Constraint_index_set)

# Register Constraint in _evaluator:
_evaluator.Constraint_swigregister(Constraint)
class IfElseConstraint(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _evaluator.IfElseConstraint_swiginit(self, _evaluator.new_IfElseConstraint())
    __swig_destroy__ = _evaluator.delete_IfElseConstraint

    def add_leaf(self, leaf):
        return _evaluator.IfElseConstraint_add_leaf(self, leaf)

    def end_condition(self):
        return _evaluator.IfElseConstraint_end_condition(self)

    def add_condition_rpn_term(self, term):
        return _evaluator.IfElseConstraint_add_condition_rpn_term(self, term)

    def add_fn_rpn_term(self, term):
        return _evaluator.IfElseConstraint_add_fn_rpn_term(self, term)

    def add_jac_rpn_term(self, v, term):
        return _evaluator.IfElseConstraint_add_jac_rpn_term(self, v, term)
    current_condition_rpn = property(_evaluator.IfElseConstraint_current_condition_rpn_get, _evaluator.IfElseConstraint_current_condition_rpn_set)
    current_fn_rpn = property(_evaluator.IfElseConstraint_current_fn_rpn_get, _evaluator.IfElseConstraint_current_fn_rpn_set)
    current_jac_rpn = property(_evaluator.IfElseConstraint_current_jac_rpn_get, _evaluator.IfElseConstraint_current_jac_rpn_set)
    condition_rpn = property(_evaluator.IfElseConstraint_condition_rpn_get, _evaluator.IfElseConstraint_condition_rpn_set)
    fn_rpn = property(_evaluator.IfElseConstraint_fn_rpn_get, _evaluator.IfElseConstraint_fn_rpn_set)
    jac_rpn = property(_evaluator.IfElseConstraint_jac_rpn_get, _evaluator.IfElseConstraint_jac_rpn_set)
    leaves = property(_evaluator.IfElseConstraint_leaves_get, _evaluator.IfElseConstraint_leaves_set)
    index = property(_evaluator.IfElseConstraint_index_get, _evaluator.IfElseConstraint_index_set)

# Register IfElseConstraint in _evaluator:
_evaluator.IfElseConstraint_swigregister(IfElseConstraint)
class Evaluator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _evaluator.Evaluator_swiginit(self, _evaluator.new_Evaluator())
    __swig_destroy__ = _evaluator.delete_Evaluator
    nnz = property(_evaluator.Evaluator_nnz_get, _evaluator.Evaluator_nnz_set)
    stack = property(_evaluator.Evaluator_stack_get, _evaluator.Evaluator_stack_set)

    def add_var(self, value):
        return _evaluator.Evaluator_add_var(self, value)

    def add_param(self, value):
        return _evaluator.Evaluator_add_param(self, value)

    def add_float(self, value):
        return _evaluator.Evaluator_add_float(self, value)

    def add_constraint(self):
        return _evaluator.Evaluator_add_constraint(self)

    def add_if_else_constraint(self):
        return _evaluator.Evaluator_add_if_else_constraint(self)

    def remove_var(self, v):
        return _evaluator.Evaluator_remove_var(self, v)

    def remove_param(self, p):
        return _evaluator.Evaluator_remove_param(self, p)

    def remove_float(self, f):
        return _evaluator.Evaluator_remove_float(self, f)

    def remove_constraint(self, c):
        return _evaluator.Evaluator_remove_constraint(self, c)

    def remove_if_else_constraint(self, c):
        return _evaluator.Evaluator_remove_if_else_constraint(self, c)

    def set_structure(self):
        return _evaluator.Evaluator_set_structure(self)

    def remove_structure(self):
        return _evaluator.Evaluator_remove_structure(self)

    def get_x(self, array_out):
        return _evaluator.Evaluator_get_x(self, array_out)

    def load_var_values_from_x(self, array_in):
        return _evaluator.Evaluator_load_var_values_from_x(self, array_in)

    def evaluate(self, array_out):
        return _evaluator.Evaluator_evaluate(self, array_out)

    def evaluate_csr_jacobian(self, values_array_out, col_ndx_array_out, row_nnz_array_out):
        return _evaluator.Evaluator_evaluate_csr_jacobian(self, values_array_out, col_ndx_array_out, row_nnz_array_out)

# Register Evaluator in _evaluator:
_evaluator.Evaluator_swigregister(Evaluator)

def _evaluate(stack, rpn, values):
    return _evaluator._evaluate(stack, rpn, values)

